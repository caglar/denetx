/*
* infogain.cc
* Created on: Apr 21, 2011
*      Author: caglar
*/

#include "infogain.h"
#include "mutils.h"
#include <cmath>

const float MINVAL = 1.6009E-16;
const float MINFRACVAL = 0.01;

/*
 * Array parameters used here should be allocated at the stack.
 */
template<size_t N, size_t M>
inline float
getMeritOfSplit(float (&preSplitDist)[N], float (&postSplitDists)[N][M])
{
  return (computeEntropy(preSplitDist) - computeEntropy(postSplitDists));
}

template<size_t N>
inline float
getRangeOfMerit(float(&preSplitDist)[N])
{
  int numClasses = (N > 2 ? N : 2);
  return log2(N);
}

template<size_t N>
inline float
computeEntropy(float(&dist)[N])
{
  float entropy = 0.0;
  float sum = 0.0;
  for (int i = 0; i < N; i++) {
    if (dist[i] > MINVAL) {
      entropy -= dist[i] * log2(dist[i]);
      sum += dist[i];
    }
  }
  return sum > 0.0 ? (entropy + sum * log2(sum)) / sum : 0.0;
}

/*
 * This function calculates the weighted entropy.
 */
template<size_t N, size_t M>
inline float
computeEntropy(float(&dist)[N][M])
{
  float totalWeight = 0.0;
  float entropy = 0.0;
  float distWeight = 0.0;
  for (int i = 0; i < N; i++) {
    distWeight = fsum(dist[i]);
    entropy += distWeight * computeEntropy(dist[i]);
    totalWeight += distWeight;
  }
  return entropy / totalWeight;
}

template<size_t N, size_t M>
inline float
numSubsetsGreaterThanFrac(float distributions[N][M], float minFrac)
{
  float totalWeight = 0.0;
  float distSums[N];

  for (int i = 0; i < N; i++) {
    distSums[i] = fsum(distributions[i]);
    totalWeight += distSums[i];
  }

  int numGreater = 0;
  for (int i = 0; i < N; i++) {
    float frac = distSums[i] / totalWeight;
    if (frac > minFrac) {
      numGreater++;
    }
  }
  return numGreater;
}
